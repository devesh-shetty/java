package com.test.java8;

import java.util.List;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.OptionalDouble;
import java.util.IntSummaryStatistics;

/**
*Exploring new JAVA8 features
*
*@author: Devesh Shetty
*/
public class NewFeatures{
    
    public static void main(String[] args){
        
        //Lambda expression
        //We can use Lambda expression to replace anonymous inner classes
        //Constraint: The interface must have only 1 abstract method
        // -> marks the body of the lambda expression
        //Thread constructor takes a Runnable
        //which has a single abstract method public void run()
        //Our lambda expression will be based on this single abstract method
        //run() takes no arguments so our lambda will take no argument
        Thread one = new Thread(() -> {
            System.out.println("Thread One");
        });
        
        //When we have a single statement in the body of the lambda expression, 
        //we can skip the '{}' braces and directly write that 1 statement
        Thread two = new Thread( () -> System.out.println("Thread Two"));
        
        one.start();
        two.start();
        
        List<Integer> list = Arrays.asList(5, 67, 21, 54, 32, 90, 98, 34, 1);
        //--------------------Functional Programming --------------------
        //we try to avoid using loops!
        //since, we have a single statement; we can skip the braces
        //the functional method accept takes a single argument
        //so our lambda expression also takes a single argument
        //the data-type of the argument 'item' will be infered
        ListUtil.forEach(list, (item) -> System.out.print(item + " "));
        System.out.println();
        
        //data-type of the argument can also be specified
        ListUtil.forEach(list, (Integer item) -> {
            //print only even numbers
            if( (item & 1) == 0){
                System.out.print(item + " ");
            }
        });
        System.out.println();
        
        //functional method test takes one argument and also returns a value
        //when we have a single statement in the lambda expression
        //the value generated by the expression gets returned automatically
        //no 'return' keyword needed
        List<Integer> evenList = ListUtil.filter(list, (item) -> (item & 1) == 0);
        ListUtil.forEach(evenList, (item) -> System.out.print(item+" "));
        System.out.println();
        
        List<Integer> squares = ListUtil.map(list, (item) -> item*item);
        ListUtil.forEach(squares, (item) -> System.out.print(item+" "));
        System.out.println();
        
        //List has a method forEach method that takes a Consumer
        list.forEach((item) -> System.out.print(item + " " ));
        System.out.println();
        
        //convert the list to a stream to perform a sequence of operations
        list.stream()
            .filter( (item) -> (item & 1) == 0)//Intermediate operation - get all even elements in the list
            .map( (item) -> item * item) //Intermediate operation - square the elements from previous stream
            .forEach((item) -> System.out.print(item+" ") );//Terminal operation
        System.out.println();
        
        //Method References
        //pass the method reference
        //static method reference syntax-> ContainingClass ::  staticMethodName
        //the below is a static method reference
        list.forEach( NewFeatures :: printSquaresAndCubes);
        
        List<Integer> oddCubes = list.stream()//convert list to a stream
                                    .filter( (item) -> (item & 1) == 1 )//intermediate operation
                                    .map( (item) -> item * item * item)//intermediate operation
                                    .collect( (Collectors.toList()));//terminal operation
        
        //instance method reference syntax  -> containingObject :: instanceMethodName
        //the below is an instance method reference
        oddCubes.forEach( System.out :: println);
        
        //calculate the average of even numbers in the list
        System.out.println( list.stream()//convert to a stream
                                .filter( (item) -> (item & 1) == 0)//intermediate operation 
                                .mapToInt((item) -> item)//intermediate operation - convert to an intStream
                                .average()//intStream provides us with utility methods like average (terminal operation)
                          );
        
        //store and display the average of odd numbers in the list
        OptionalDouble optionalDoubleAverage = list.stream()
                                                .filter((item) -> (item & 1) == 1 )
                                                .mapToInt( item -> item )// if the lambda takes only a single argument, we can drop the ()
                                                //i.e. instead of (item) -> item, we can use the one above
                                                .average();//terminal operation
        
        //if the list is empty then instead of returning null, an OptionalDouble object is returned
        // which has no value
        //It is based on "Null Object Pattern" wherein instead of returning a null, a object with no value is returned
        if(optionalDoubleAverage.isPresent()){
            //value is present
            System.out.println("The average of odd numbers in the list: "+optionalDoubleAverage.getAsDouble());
        }
        else{
            //list is empty
            System.out.println("The list is empty");
        }
        
        IntSummaryStatistics stats = list.stream()
                                        .mapToInt( item -> item )//intermediate operation
                                        .summaryStatistics();//terminal operation
        
        System.out.println(stats);
        
        System.out.println("List data:\n Sum: "+stats.getSum() +" Count: "+stats.getCount() + " Average: "+stats.getAverage()
                                                +" Min: "+stats.getMin()+" Max: "+stats.getMax());
        
        
    }
    
    private static void printSquaresAndCubes(Integer item){
        
        if( (item & 1) == 0){
            //even nos
            System.out.println(item * item);
        }else{
            //odd nos
            System.out.println(item * item * item);
        }
        
    }
    
}